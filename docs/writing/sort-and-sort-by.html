<!DOCTYPE html>
<meta charset="utf-8">
<title>Larry Fox</title>
<meta content="width=device-width,initial-scale=1" name="viewport">

<style>
  body {
    max-width: 38rem;
    margin: 1.5em 1.5em 100px;
    font-family: georgia, serif;
    line-height: 1.5;
  }
  h2 {
    font-size: 0.875em;
    font-family: -apple-system, sans-serif;
  }
  a { color: #00f; }
</style>

<body>
  
  <h2>sort and sort_by</h2>
  

  <p>A quick brief of Ruby’s sorting algorithm.</p>

<pre><code class="language-ruby">@count = 0
an_array = [].fill(0...1000) { rand(1000) }

an_array.sort do |a, b|
  @count += 1
  a &lt;=&gt; b
end

@count # =&gt; 8982
</code></pre>

<p>The above sorts a random 1000 element array, calling its block 8982 times. That exact count will vary, but since Ruby uses <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a> under the hood, we can expect <em>O(n log n)</em> comparisons for an array of length <em>n</em>. With that in mind let’s imagine that we need to sort an array based on a property of its elements. For example, to sort email addresses by TLD we might code this up.</p>

<pre><code class="language-ruby">def extract_tld(email)
  @count += 1
  email.split('.').last
end

emails = %w[
  lisa@example.net
  bill@example.com
  sara@example.info
  jack@example.us
  jill@example.org
]

emails.sort do |a, b|
  extract_tld(a) &lt;=&gt; extract_tld(b)
end
</code></pre>

<p>This works, and will probably get the job done, but how many times does our inconspicuous method get called on this tiny 5 element array?</p>

<pre><code class="language-ruby">@count # =&gt; 14
</code></pre>

<p>No surprise here, <code>#extract_tld</code> is getting called twice for each comparison, which means some email addresses are getting computed more that once.</p>

<p>This example is trivial but with larger data sets and more expensive operations this problem can balloon. We can fix this by doing some preprocessing on our input, namely using the <a href="https://en.wikipedia.org/wiki/Schwartzian_transform">Schwartzian Transform</a>. The basic idea is this:</p>

<ol>
<li>Map over the input, and return a 2 element array, consisting of a preprocessed sorting key, and the original value. So <code>[item_1, … item_n]</code> becomes <code>[[key_1, item_1], … [key_n, item_n]]</code>.</li>
<li>Perform sort based on the first element of the sub arrays.</li>
<li>Map over the array again, reversing the effect of step 1.</li>
</ol>

<p>Translated to Ruby, and annotated to display what&rsquo;s going on:</p>

<pre><code class="language-ruby">emails
        # =&gt;[&quot;lisa@example.net&quot;, &quot;bill@example.com&quot;, &quot;sara@example.info&quot;, &quot;jack@example.us&quot;, &quot;jill@example.org&quot;]
  .map { |x| [extract_tld(x), x] }
        # =&gt; [[&quot;net&quot;, &quot;lisa@example.net&quot;], [&quot;com&quot;, &quot;bill@example.com&quot;], [&quot;info&quot;, &quot;sara@example.info&quot;], [&quot;us&quot;, &quot;jack@example.us&quot;], [&quot;org&quot;, &quot;jill@example.org&quot;]]
  .sort
        # =&gt; [[&quot;com&quot;, &quot;bill@example.com&quot;], [&quot;info&quot;, &quot;sara@example.info&quot;], [&quot;net&quot;, &quot;lisa@example.net&quot;], [&quot;org&quot;, &quot;jill@example.org&quot;], [&quot;us&quot;, &quot;jack@example.us&quot;]]
  .map { |x| x[1] }
        # =&gt; [&quot;bill@example.com&quot;, &quot;sara@example.info&quot;, &quot;lisa@example.net&quot;, &quot;jill@example.org&quot;, &quot;jack@example.us&quot;]

@count # =&gt; 5
</code></pre>

<p>Now instead of <em>O(n log n)</em> calls to <code>#extract_tld</code>, we&rsquo;re doing exactly <em>n</em> of them, in this case 5. This concept is so useful that Ruby actually has it built in (and implemented in C). It&rsquo;s what <code>#sort_by</code> does in the background. So the above could even be shortened to this more readable one liner:</p>

<pre><code class="language-ruby">emails.sort_by { |x| extract_tld(x) }
@count # =&gt; 5
</code></pre>

<p>Note that <code>#sort</code> is generally faster for simple comparisons, and <code>#sort_by</code> for more complex comparisons; as with most things, choose the right tool for the job. The Ruby docs for <a href="http://www.ruby-doc.org/core-2.1.2/Enumerable.html#method-i-sort_by"><code>#sort_by</code></a> touch on this a bit more. Benchmarking <a href="https://gist.github.com/larryfox/b999ef8484e5a2e61024">with examples</a> from this post I get the following:</p>

<pre><code class="language-json">Comparison:
            sort_by:     1108.4 i/s
       map.sort.map:      323.2 i/s - 3.43x slower
               sort:      283.8 i/s - 3.91x slower
</code></pre>

</body>
